import "./chunk-67LFQLQL.js";
import {
  derived,
  writable
} from "./chunk-HBISGCUC.js";
import {
  linear,
  sqrt
} from "./chunk-XBLPXQ7K.js";
import {
  rgb
} from "./chunk-SARWLFPZ.js";
import {
  InternSet,
  ascending,
  bin
} from "./chunk-3VW5CGFU.js";
import {
  stack_default
} from "./chunk-5R7OMHTK.js";
import {
  onMount
} from "./chunk-ZTESL264.js";
import "./chunk-CCZC47PA.js";
import "./chunk-FOEVII3Z.js";
import {
  add_locations,
  append_styles,
  bind_element_size,
  bind_this,
  check_target,
  cleanup_styles,
  hmr,
  if_block,
  init,
  legacy_api,
  log_if_contains_state,
  prop,
  set_attribute,
  set_style,
  setup_stores,
  slot,
  store_get,
  store_set,
  validate_store
} from "./chunk-YLKNKNTM.js";
import "./chunk-WXVJ3F4R.js";
import "./chunk-ESH5TA73.js";
import {
  append,
  comment,
  ns_template,
  set_text,
  template,
  text
} from "./chunk-3DC2YMOI.js";
import "./chunk-NTEN4E7E.js";
import {
  FILENAME,
  HMR,
  child,
  deep_read_state,
  first_child,
  get,
  getContext,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  mutable_state,
  mutate,
  pop,
  push,
  reset,
  set,
  setContext,
  sibling,
  strict_equals,
  template_effect
} from "./chunk-J4O3X5JB.js";
import "./chunk-UICVJCEF.js";
import "./chunk-UGBVNEQM.js";

// node_modules/layercake/dist/utils/canBeZero.js
function canBeZero(val) {
  if (val === 0) {
    return true;
  }
  return val;
}

// node_modules/layercake/dist/utils/makeAccessor.js
function makeAccessor(acc) {
  if (!canBeZero(acc)) return null;
  if (Array.isArray(acc)) {
    return (d) => acc.map((k) => {
      return typeof k !== "function" ? d[k] : k(d);
    });
  } else if (typeof acc !== "function") {
    return (d) => d[acc];
  }
  return acc;
}

// node_modules/layercake/dist/utils/filterObject.js
function filterObject(obj, comparisonObj = {}) {
  return Object.fromEntries(
    Object.entries(obj).filter(([key, value]) => {
      return value !== void 0 && comparisonObj[key] === void 0;
    })
  );
}

// node_modules/layercake/dist/utils/debounce.js
function debounce(func, timeout = 300) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, timeout);
  };
}

// node_modules/layercake/dist/lib/calcUniques.js
function calcUniques(data, fields, sortOptions = {}) {
  if (!Array.isArray(data)) {
    throw new TypeError(
      `The first argument of calcUniques() must be an array. You passed in a ${typeof data}. If you got this error using the <LayerCake> component, consider passing a flat array to the \`flatData\` prop. More info: https://layercake.graphics/guide/#flatdata`
    );
  }
  if (Array.isArray(fields) || fields === void 0 || fields === null) {
    throw new TypeError(
      "The second argument of calcUniques() must be an object with field names as keys as accessor functions as values."
    );
  }
  const uniques2 = {};
  const keys = Object.keys(fields);
  const kl = keys.length;
  let i;
  let j;
  let k;
  let s;
  let acc;
  let val;
  let set2;
  const dl = data.length;
  for (i = 0; i < kl; i += 1) {
    set2 = new InternSet();
    s = keys[i];
    acc = fields[s];
    for (j = 0; j < dl; j += 1) {
      val = acc(data[j]);
      if (Array.isArray(val)) {
        const vl = val.length;
        for (k = 0; k < vl; k += 1) {
          set2.add(val[k]);
        }
      } else {
        set2.add(val);
      }
    }
    const results = Array.from(set2);
    if (sortOptions.sort === true || sortOptions[s] === true) {
      results.sort(ascending);
    }
    uniques2[s] = results;
  }
  return uniques2;
}

// node_modules/layercake/dist/lib/calcExtents.js
function calcExtents(data, fields) {
  if (!Array.isArray(data)) {
    throw new TypeError(
      `The first argument of calcExtents() must be an array. You passed in a ${typeof data}. If you got this error using the <LayerCake> component, consider passing a flat array to the \`flatData\` prop. More info: https://layercake.graphics/guide/#flatdata`
    );
  }
  if (Array.isArray(fields) || fields === void 0 || fields === null) {
    throw new TypeError(
      "The second argument of calcExtents() must be an object with field names as keys as accessor functions as values."
    );
  }
  const extents = {};
  const keys = Object.keys(fields);
  const kl = keys.length;
  let i;
  let j;
  let k;
  let s;
  let min;
  let max;
  let acc;
  let val;
  const dl = data.length;
  for (i = 0; i < kl; i += 1) {
    s = keys[i];
    acc = fields[s];
    min = null;
    max = null;
    for (j = 0; j < dl; j += 1) {
      val = acc(data[j], j);
      if (Array.isArray(val)) {
        const vl = val.length;
        for (k = 0; k < vl; k += 1) {
          if (val[k] !== false && val[k] !== void 0 && val[k] !== null && Number.isNaN(val[k]) === false) {
            if (min === null || val[k] < min) {
              min = val[k];
            }
            if (max === null || val[k] > max) {
              max = val[k];
            }
          }
        }
      } else if (val !== false && val !== void 0 && val !== null && Number.isNaN(val) === false) {
        if (min === null || val < min) {
          min = val;
        }
        if (max === null || val > max) {
          max = val;
        }
      }
    }
    extents[s] = [min, max];
  }
  return extents;
}

// node_modules/layercake/dist/utils/arraysEqual.js
function arraysEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) return false;
  return arr1.every((k) => {
    return arr2.includes(k);
  });
}

// node_modules/layercake/dist/helpers/isOrdinalDomain.js
function isOrdinalDomain(scale) {
  if (typeof scale.bandwidth === "function") {
    return true;
  }
  if (arraysEqual(Object.keys(scale), ["domain", "range", "unknown", "copy"])) {
    return true;
  }
  return false;
}

// node_modules/layercake/dist/helpers/calcScaleExtents.js
function calcScaleExtents(flatData, getters, activeScales) {
  const scaleGroups = Object.entries(activeScales).reduce(
    (groups, [k, scaleInfo]) => {
      const domainType = isOrdinalDomain(scaleInfo.scale) === true ? "ordinal" : "other";
      if (!groups[domainType]) groups[domainType] = {};
      groups[domainType][k] = getters[k];
      return groups;
    },
    { ordinal: false, other: false }
  );
  let extents = {};
  if (scaleGroups.ordinal) {
    const sortOptions = Object.fromEntries(
      Object.entries(activeScales).map(([k, scaleInfo]) => {
        return [k, scaleInfo.sort];
      })
    );
    extents = calcUniques(flatData, scaleGroups.ordinal, sortOptions);
  }
  if (scaleGroups.other) {
    extents = { ...extents, ...calcExtents(flatData, scaleGroups.other) };
  }
  return extents;
}

// node_modules/layercake/dist/utils/partialDomain.js
function partialDomain(domain = [], directive) {
  if (Array.isArray(directive) === true) {
    return directive.map((d, i) => {
      if (d === null) {
        return domain[i];
      }
      return d;
    });
  }
  return domain;
}

// node_modules/layercake/dist/helpers/calcDomain.js
function calcDomain(s) {
  return function domainCalc([$extents, $domain]) {
    if (typeof $domain === "function") {
      $domain = $domain($extents[s]);
    }
    return $extents ? partialDomain($extents[s], $domain) : $domain;
  };
}

// node_modules/layercake/dist/settings/defaultScales.js
var defaultScales_default = {
  x: linear,
  y: linear,
  z: linear,
  r: sqrt
};

// node_modules/layercake/dist/helpers/findScaleType.js
function findScaleType(scale) {
  if (scale.constant) {
    return "symlog";
  }
  if (scale.base) {
    return "log";
  }
  if (scale.exponent) {
    if (scale.exponent() === 0.5) {
      return "sqrt";
    }
    return "pow";
  }
  return "other";
}

// node_modules/layercake/dist/utils/identity.js
function identity(d) {
  return d;
}

// node_modules/layercake/dist/helpers/getPadFunctions.js
function log(sign) {
  return (x) => Math.log(sign * x);
}
function exp(sign) {
  return (x) => sign * Math.exp(x);
}
function symlog(c) {
  return (x) => Math.sign(x) * Math.log1p(Math.abs(x / c));
}
function symexp(c) {
  return (x) => Math.sign(x) * Math.expm1(Math.abs(x)) * c;
}
function pow(exponent) {
  return function powFn(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}
function getPadFunctions(scale) {
  const scaleType = findScaleType(scale);
  if (scaleType === "log") {
    const sign = Math.sign(scale.domain()[0]);
    return { lift: log(sign), ground: exp(sign), scaleType };
  }
  if (scaleType === "pow") {
    const exponent = 1;
    return { lift: pow(exponent), ground: pow(1 / exponent), scaleType };
  }
  if (scaleType === "sqrt") {
    const exponent = 0.5;
    return { lift: pow(exponent), ground: pow(1 / exponent), scaleType };
  }
  if (scaleType === "symlog") {
    const constant = 1;
    return { lift: symlog(constant), ground: symexp(constant), scaleType };
  }
  return { lift: identity, ground: identity, scaleType };
}

// node_modules/layercake/dist/helpers/toTitleCase.js
function toTitleCase(str) {
  return str.replace(/^\w/, (d) => d.toUpperCase());
}

// node_modules/layercake/dist/helpers/findScaleName.js
function f(name, modifier = "") {
  return `scale${toTitleCase(modifier)}${toTitleCase(name)}`;
}
function findScaleName(scale) {
  if (typeof scale.bandwidth === "function") {
    if (typeof scale.paddingInner === "function") {
      return f("band");
    }
    return f("point");
  }
  if (arraysEqual(Object.keys(scale), ["domain", "range", "unknown", "copy"])) {
    return f("ordinal");
  }
  let modifier = "";
  if (scale.interpolator) {
    if (scale.domain().length === 3) {
      modifier = "diverging";
    } else {
      modifier = "sequential";
    }
  }
  if (scale.quantiles) {
    return f("quantile", modifier);
  }
  if (scale.thresholds) {
    return f("quantize", modifier);
  }
  if (scale.constant) {
    return f("symlog", modifier);
  }
  if (scale.base) {
    return f("log", modifier);
  }
  if (scale.exponent) {
    if (scale.exponent() === 0.5) {
      return f("sqrt", modifier);
    }
    return f("pow", modifier);
  }
  if (arraysEqual(Object.keys(scale), ["domain", "range", "invertExtent", "unknown", "copy"])) {
    return f("threshold");
  }
  if (arraysEqual(Object.keys(scale), [
    "invert",
    "range",
    "domain",
    "unknown",
    "copy",
    "ticks",
    "tickFormat",
    "nice"
  ])) {
    return f("identity");
  }
  if (arraysEqual(Object.keys(scale), [
    "invert",
    "domain",
    "range",
    "rangeRound",
    "round",
    "clamp",
    "unknown",
    "copy",
    "ticks",
    "tickFormat",
    "nice"
  ])) {
    return f("radial");
  }
  if (modifier) {
    return f(modifier);
  }
  if (scale.domain()[0] instanceof Date) {
    const d = /* @__PURE__ */ new Date();
    let s;
    d.getDay = () => s = "time";
    d.getUTCDay = () => s = "utc";
    scale.tickFormat(0, "%a")(d);
    return f(s);
  }
  return f("linear");
}

// node_modules/layercake/dist/utils/padScale.js
var unpaddable = ["scaleThreshold", "scaleQuantile", "scaleQuantize", "scaleSequentialQuantile"];
function padScale(scale, padding) {
  if (typeof scale.range !== "function") {
    throw new Error("Scale method `range` must be a function");
  }
  if (typeof scale.domain !== "function") {
    throw new Error("Scale method `domain` must be a function");
  }
  if (!Array.isArray(padding) || unpaddable.includes(findScaleName(scale))) {
    return scale.domain();
  }
  if (isOrdinalDomain(scale) === true) {
    return scale.domain();
  }
  const { lift, ground } = getPadFunctions(scale);
  const d0 = scale.domain()[0];
  const isTime = Object.prototype.toString.call(d0) === "[object Date]";
  const [d1, d2] = scale.domain().map((d) => {
    return isTime ? lift(d.getTime()) : lift(d);
  });
  const [r1, r2] = scale.range();
  const paddingLeft = padding[0] || 0;
  const paddingRight = padding[1] || 0;
  const step = (d2 - d1) / (Math.abs(r2 - r1) - paddingLeft - paddingRight);
  return [d1 - paddingLeft * step, paddingRight * step + d2].map((d) => {
    return isTime ? ground(new Date(d)) : ground(d);
  });
}

// node_modules/layercake/dist/settings/getDefaultRange.js
function calcBaseRange(s, width, height, reverse, percentRange) {
  let min;
  let max;
  if (percentRange === true) {
    min = 0;
    max = 100;
  } else {
    min = s === "r" ? 1 : 0;
    max = s === "y" ? height : s === "r" ? 25 : width;
  }
  return reverse === true ? [max, min] : [min, max];
}
function getDefaultRange(s, width, height, reverse, range, percentRange) {
  return !range ? calcBaseRange(s, width, height, reverse, percentRange) : typeof range === "function" ? range({ width, height }) : range;
}

// node_modules/layercake/dist/helpers/createScale.js
function createScale(s) {
  return function scaleCreator([
    $scale,
    $extents,
    $domain,
    $padding,
    $nice,
    $reverse,
    $width,
    $height,
    $range,
    $percentScale
  ]) {
    if ($extents === null) {
      return null;
    }
    const defaultRange = getDefaultRange(s, $width, $height, $reverse, $range, $percentScale);
    const scale = $scale === defaultScales_default[s] ? $scale() : $scale.copy();
    scale.domain($domain);
    if (!scale.interpolator || typeof scale.interpolator === "function" && scale.interpolator().name.startsWith("identity")) {
      scale.range(defaultRange);
    }
    if ($padding) {
      scale.domain(padScale(scale, $padding));
    }
    if ($nice === true || typeof $nice === "number") {
      if (typeof scale.nice === "function") {
        scale.nice(typeof $nice === "number" ? $nice : void 0);
      } else {
        console.error(
          `[Layer Cake] You set \`${s}Nice: true\` but the ${s}Scale does not have a \`.nice\` method. Ignoring...`
        );
      }
    }
    return scale;
  };
}

// node_modules/layercake/dist/helpers/createGetter.js
function createGetter([$acc, $scale]) {
  return (d, i) => {
    const val = $acc(d, i);
    if (Array.isArray(val)) {
      return val.map((v) => $scale(v));
    }
    return $scale(val);
  };
}

// node_modules/layercake/dist/helpers/getRange.js
function getRange([$scale]) {
  if (typeof $scale === "function") {
    if (typeof $scale.range === "function") {
      return $scale.range();
    }
    console.error("[LayerCake] Your scale doesn't have a `.range` method?");
  }
  return null;
}

// node_modules/layercake/dist/helpers/printDebug.js
var indent = "    ";
function getRgb(clr) {
  const { r, g, b, opacity: o } = rgb(clr);
  if (![r, g, b].every((c) => c >= 0 && c <= 255)) {
    return false;
  }
  return { r, g, b, o };
}
function contrast({ r, g, b }) {
  const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
  return luminance > 0.6 ? "black" : "white";
}
function printDebug(obj) {
  console.log("/********* LayerCake Debug ************/");
  console.log("Bounding box:");
  printObject(obj.boundingBox);
  console.log("Data:");
  console.log(indent, obj.data);
  if (obj.flatData) {
    console.log("flatData:");
    console.log(indent, obj.flatData);
  }
  console.log("Scales:");
  Object.keys(obj.activeGetters).forEach((g) => {
    printScale(g, obj[`${g}Scale`], obj[g]);
  });
  console.log("/************ End LayerCake Debug ***************/\n");
}
function printObject(obj) {
  Object.entries(obj).forEach(([key, value]) => {
    console.log(`${indent}${key}:`, value);
  });
}
function printScale(s, scale, acc) {
  const scaleName = findScaleName(scale);
  console.log(`${indent}${s}:`);
  console.log(`${indent}${indent}Accessor: "${acc.toString()}"`);
  console.log(`${indent}${indent}Type: ${scaleName}`);
  printValues(scale, "domain");
  printValues(scale, "range", " ");
}
function printValues(scale, method, extraSpace = "") {
  const values = scale[method]();
  const colorValues = colorizeArray(values);
  if (colorValues) {
    printColorArray(colorValues, method, values);
  } else {
    console.log(`${indent}${indent}${toTitleCase(method)}:${extraSpace}`, values);
  }
}
function printColorArray(colorValues, method, values) {
  console.log(
    `${indent}${indent}${toTitleCase(method)}:    %cArray%c(${values.length}) ` + colorValues[0] + "%c ]",
    "color: #1377e4",
    "color: #737373",
    "color: #1478e4",
    ...colorValues[1],
    "color: #1478e4"
  );
}
function colorizeArray(arr) {
  const colors = [];
  const a = arr.map((d, i) => {
    const rgbo = getRgb(d);
    if (rgbo !== false) {
      colors.push(rgbo);
      const space = i === arr.length - 1 ? " " : "";
      return `%c ${d}${space}`;
    }
    return d;
  });
  if (colors.length) {
    return [
      `%c[ ${a.join(", ")}`,
      colors.map(
        (d) => `background-color: rgba(${d.r}, ${d.g}, ${d.b}, ${d.o}); color:${contrast(d)};`
      )
    ];
  }
  return null;
}

// node_modules/layercake/dist/LayerCake.svelte
mark_module_start();
LayerCake[FILENAME] = "node_modules/layercake/dist/LayerCake.svelte";
var root_1 = add_locations(template(`<div class="layercake-container s-iXYfEl0mczxA"><!></div>`), LayerCake[FILENAME], [[534, 1]]);
var $$css = {
  hash: "s-iXYfEl0mczxA",
  code: "\n	.layercake-container.s-iXYfEl0mczxA,\n	.layercake-container.s-iXYfEl0mczxA * {\n		box-sizing: border-box;\n	}\n	.layercake-container.s-iXYfEl0mczxA {\n		width: 100%;\n		height: 100%;\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGF5ZXJDYWtlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiO0FBeWxCQSxDQUFDLG1DQUFvQjtBQUNyQixDQUFDLG1DQUFvQixDQUFTLENBQUUsQ0FBQztBQUNqQyxFQUFFLHNCQUFzQjtBQUN4QjtBQUNBLENBQUMsbUNBQW9CLENBQUM7QUFDdEIsRUFBRSxXQUFXO0FBQ2IsRUFBRSxZQUFZO0FBQ2QiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkxheWVyQ2FrZS5zdmVsdGUiXX0= */"
};
function LayerCake($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, LayerCake);
  append_styles($$anchor, $$css);
  const $$stores = setup_stores();
  const $_percentRange = () => (validate_store(_percentRange, "_percentRange"), store_get(_percentRange, "$_percentRange", $$stores));
  const $_containerWidth = () => (validate_store(_containerWidth, "_containerWidth"), store_get(_containerWidth, "$_containerWidth", $$stores));
  const $_containerHeight = () => (validate_store(_containerHeight, "_containerHeight"), store_get(_containerHeight, "$_containerHeight", $$stores));
  const $_extents = () => (validate_store(_extents, "_extents"), store_get(_extents, "$_extents", $$stores));
  const $_data = () => (validate_store(_data, "_data"), store_get(_data, "$_data", $$stores));
  const $_flatData = () => (validate_store(_flatData, "_flatData"), store_get(_flatData, "$_flatData", $$stores));
  const $_padding = () => (validate_store(_padding, "_padding"), store_get(_padding, "$_padding", $$stores));
  const $_x = () => (validate_store(_x, "_x"), store_get(_x, "$_x", $$stores));
  const $_y = () => (validate_store(_y, "_y"), store_get(_y, "$_y", $$stores));
  const $_z = () => (validate_store(_z, "_z"), store_get(_z, "$_z", $$stores));
  const $_r = () => (validate_store(_r, "_r"), store_get(_r, "$_r", $$stores));
  const $_xDomain = () => (validate_store(_xDomain, "_xDomain"), store_get(_xDomain, "$_xDomain", $$stores));
  const $_yDomain = () => (validate_store(_yDomain, "_yDomain"), store_get(_yDomain, "$_yDomain", $$stores));
  const $_zDomain = () => (validate_store(_zDomain, "_zDomain"), store_get(_zDomain, "$_zDomain", $$stores));
  const $_rDomain = () => (validate_store(_rDomain, "_rDomain"), store_get(_rDomain, "$_rDomain", $$stores));
  const $_xNice = () => (validate_store(_xNice, "_xNice"), store_get(_xNice, "$_xNice", $$stores));
  const $_yNice = () => (validate_store(_yNice, "_yNice"), store_get(_yNice, "$_yNice", $$stores));
  const $_zNice = () => (validate_store(_zNice, "_zNice"), store_get(_zNice, "$_zNice", $$stores));
  const $_rNice = () => (validate_store(_rNice, "_rNice"), store_get(_rNice, "$_rNice", $$stores));
  const $_xReverse = () => (validate_store(_xReverse, "_xReverse"), store_get(_xReverse, "$_xReverse", $$stores));
  const $_yReverse = () => (validate_store(_yReverse, "_yReverse"), store_get(_yReverse, "$_yReverse", $$stores));
  const $_zReverse = () => (validate_store(_zReverse, "_zReverse"), store_get(_zReverse, "$_zReverse", $$stores));
  const $_rReverse = () => (validate_store(_rReverse, "_rReverse"), store_get(_rReverse, "$_rReverse", $$stores));
  const $_xPadding = () => (validate_store(_xPadding, "_xPadding"), store_get(_xPadding, "$_xPadding", $$stores));
  const $_yPadding = () => (validate_store(_yPadding, "_yPadding"), store_get(_yPadding, "$_yPadding", $$stores));
  const $_zPadding = () => (validate_store(_zPadding, "_zPadding"), store_get(_zPadding, "$_zPadding", $$stores));
  const $_rPadding = () => (validate_store(_rPadding, "_rPadding"), store_get(_rPadding, "$_rPadding", $$stores));
  const $_xRange = () => (validate_store(_xRange, "_xRange"), store_get(_xRange, "$_xRange", $$stores));
  const $_yRange = () => (validate_store(_yRange, "_yRange"), store_get(_yRange, "$_yRange", $$stores));
  const $_zRange = () => (validate_store(_zRange, "_zRange"), store_get(_zRange, "$_zRange", $$stores));
  const $_rRange = () => (validate_store(_rRange, "_rRange"), store_get(_rRange, "$_rRange", $$stores));
  const $_xScale = () => (validate_store(_xScale, "_xScale"), store_get(_xScale, "$_xScale", $$stores));
  const $_yScale = () => (validate_store(_yScale, "_yScale"), store_get(_yScale, "$_yScale", $$stores));
  const $_zScale = () => (validate_store(_zScale, "_zScale"), store_get(_zScale, "$_zScale", $$stores));
  const $_rScale = () => (validate_store(_rScale, "_rScale"), store_get(_rScale, "$_rScale", $$stores));
  const $_custom = () => (validate_store(_custom, "_custom"), store_get(_custom, "$_custom", $$stores));
  const $_config = () => (validate_store(_config, "_config"), store_get(_config, "$_config", $$stores));
  const $box_d = () => (validate_store(box_d, "box_d"), store_get(box_d, "$box_d", $$stores));
  const $activeGetters_d = () => (validate_store(activeGetters_d, "activeGetters_d"), store_get(activeGetters_d, "$activeGetters_d", $$stores));
  const $xScale_d = () => (validate_store(xScale_d, "xScale_d"), store_get(xScale_d, "$xScale_d", $$stores));
  const $yScale_d = () => (validate_store(yScale_d, "yScale_d"), store_get(yScale_d, "$yScale_d", $$stores));
  const $zScale_d = () => (validate_store(zScale_d, "zScale_d"), store_get(zScale_d, "$zScale_d", $$stores));
  const $rScale_d = () => (validate_store(rScale_d, "rScale_d"), store_get(rScale_d, "$rScale_d", $$stores));
  const $width_d = () => (validate_store(width_d, "width_d"), store_get(width_d, "$width_d", $$stores));
  const $height_d = () => (validate_store(height_d, "height_d"), store_get(height_d, "$height_d", $$stores));
  const $aspectRatio_d = () => (validate_store(aspectRatio_d, "aspectRatio_d"), store_get(aspectRatio_d, "$aspectRatio_d", $$stores));
  const $_xDomainSort = () => (validate_store(_xDomainSort, "_xDomainSort"), store_get(_xDomainSort, "$_xDomainSort", $$stores));
  const $_yDomainSort = () => (validate_store(_yDomainSort, "_yDomainSort"), store_get(_yDomainSort, "$_yDomainSort", $$stores));
  const $_zDomainSort = () => (validate_store(_zDomainSort, "_zDomainSort"), store_get(_zDomainSort, "$_zDomainSort", $$stores));
  const $_rDomainSort = () => (validate_store(_rDomainSort, "_rDomainSort"), store_get(_rDomainSort, "$_rDomainSort", $$stores));
  const $padding_d = () => (validate_store(padding_d, "padding_d"), store_get(padding_d, "$padding_d", $$stores));
  const $extents_d = () => (validate_store(extents_d, "extents_d"), store_get(extents_d, "$extents_d", $$stores));
  const $xDomain_d = () => (validate_store(xDomain_d, "xDomain_d"), store_get(xDomain_d, "$xDomain_d", $$stores));
  const $yDomain_d = () => (validate_store(yDomain_d, "yDomain_d"), store_get(yDomain_d, "$yDomain_d", $$stores));
  const $zDomain_d = () => (validate_store(zDomain_d, "zDomain_d"), store_get(zDomain_d, "$zDomain_d", $$stores));
  const $rDomain_d = () => (validate_store(rDomain_d, "rDomain_d"), store_get(rDomain_d, "$rDomain_d", $$stores));
  const $xRange_d = () => (validate_store(xRange_d, "xRange_d"), store_get(xRange_d, "$xRange_d", $$stores));
  const $yRange_d = () => (validate_store(yRange_d, "yRange_d"), store_get(yRange_d, "$yRange_d", $$stores));
  const $zRange_d = () => (validate_store(zRange_d, "zRange_d"), store_get(zRange_d, "$zRange_d", $$stores));
  const $rRange_d = () => (validate_store(rRange_d, "rRange_d"), store_get(rRange_d, "$rRange_d", $$stores));
  const $xGet_d = () => (validate_store(xGet_d, "xGet_d"), store_get(xGet_d, "$xGet_d", $$stores));
  const $yGet_d = () => (validate_store(yGet_d, "yGet_d"), store_get(yGet_d, "$yGet_d", $$stores));
  const $zGet_d = () => (validate_store(zGet_d, "zGet_d"), store_get(zGet_d, "$zGet_d", $$stores));
  const $rGet_d = () => (validate_store(rGet_d, "rGet_d"), store_get(rGet_d, "$rGet_d", $$stores));
  const yReverseValue = mutable_state();
  const context = mutable_state();
  const printDebug_debounced = debounce(printDebug, 200);
  let ssr = prop($$props, "ssr", 8, false);
  let pointerEvents = prop($$props, "pointerEvents", 8, true);
  let position = prop($$props, "position", 8, "relative");
  let percentRange = prop($$props, "percentRange", 8, false);
  let width = prop($$props, "width", 8, void 0);
  let height = prop($$props, "height", 8, void 0);
  let containerWidth = prop($$props, "containerWidth", 28, () => width() || 100);
  let containerHeight = prop($$props, "containerHeight", 28, () => height() || 100);
  let element = prop($$props, "element", 12, void 0);
  let x = prop($$props, "x", 8, void 0);
  let y = prop($$props, "y", 8, void 0);
  let z = prop($$props, "z", 8, void 0);
  let r = prop($$props, "r", 8, void 0);
  let data = prop($$props, "data", 24, () => []);
  let xDomain = prop($$props, "xDomain", 8, void 0);
  let yDomain = prop($$props, "yDomain", 8, void 0);
  let zDomain = prop($$props, "zDomain", 8, void 0);
  let rDomain = prop($$props, "rDomain", 8, void 0);
  let xNice = prop($$props, "xNice", 8, false);
  let yNice = prop($$props, "yNice", 8, false);
  let zNice = prop($$props, "zNice", 8, false);
  let rNice = prop($$props, "rNice", 8, false);
  let xPadding = prop($$props, "xPadding", 8, void 0);
  let yPadding = prop($$props, "yPadding", 8, void 0);
  let zPadding = prop($$props, "zPadding", 8, void 0);
  let rPadding = prop($$props, "rPadding", 8, void 0);
  let xScale = prop($$props, "xScale", 24, () => defaultScales_default.x);
  let yScale = prop($$props, "yScale", 24, () => defaultScales_default.y);
  let zScale = prop($$props, "zScale", 24, () => defaultScales_default.z);
  let rScale = prop($$props, "rScale", 24, () => defaultScales_default.r);
  let xRange = prop($$props, "xRange", 8, void 0);
  let yRange = prop($$props, "yRange", 8, void 0);
  let zRange = prop($$props, "zRange", 8, void 0);
  let rRange = prop($$props, "rRange", 8, void 0);
  let xReverse = prop($$props, "xReverse", 8, false);
  let yReverse = prop($$props, "yReverse", 8, void 0);
  let zReverse = prop($$props, "zReverse", 8, false);
  let rReverse = prop($$props, "rReverse", 8, false);
  let xDomainSort = prop($$props, "xDomainSort", 8, true);
  let yDomainSort = prop($$props, "yDomainSort", 8, true);
  let zDomainSort = prop($$props, "zDomainSort", 8, true);
  let rDomainSort = prop($$props, "rDomainSort", 8, true);
  let padding = prop($$props, "padding", 24, () => ({}));
  let extents = prop($$props, "extents", 24, () => ({}));
  let flatData = prop($$props, "flatData", 8, void 0);
  let custom = prop($$props, "custom", 24, () => ({}));
  let debug = prop($$props, "debug", 8, false);
  let verbose = prop($$props, "verbose", 8, true);
  let isMounted = false;
  onMount(() => {
    isMounted = true;
  });
  const config = mutable_state({});
  const _percentRange = writable(percentRange());
  const _containerWidth = writable(containerWidth());
  const _containerHeight = writable(containerHeight());
  const _extents = writable(filterObject(extents()));
  const _data = writable(data());
  const _flatData = writable(flatData() || data());
  const _padding = writable(padding());
  const _x = writable(makeAccessor(x()));
  const _y = writable(makeAccessor(y()));
  const _z = writable(makeAccessor(z()));
  const _r = writable(makeAccessor(r()));
  const _xDomain = writable(xDomain());
  const _yDomain = writable(yDomain());
  const _zDomain = writable(zDomain());
  const _rDomain = writable(rDomain());
  const _xNice = writable(xNice());
  const _yNice = writable(yNice());
  const _zNice = writable(zNice());
  const _rNice = writable(rNice());
  const _xReverse = writable(xReverse());
  const _yReverse = writable(get(yReverseValue));
  const _zReverse = writable(zReverse());
  const _rReverse = writable(rReverse());
  const _xPadding = writable(xPadding());
  const _yPadding = writable(yPadding());
  const _zPadding = writable(zPadding());
  const _rPadding = writable(rPadding());
  const _xRange = writable(xRange());
  const _yRange = writable(yRange());
  const _zRange = writable(zRange());
  const _rRange = writable(rRange());
  const _xScale = writable(xScale());
  const _yScale = writable(yScale());
  const _zScale = writable(zScale());
  const _rScale = writable(rScale());
  const _xDomainSort = writable(xDomainSort());
  const _yDomainSort = writable(yDomainSort());
  const _zDomainSort = writable(zDomainSort());
  const _rDomainSort = writable(rDomainSort());
  const _config = writable(get(config));
  const _custom = writable(custom());
  const activeGetters_d = derived([_x, _y, _z, _r], ([$x, $y, $z, $r]) => {
    const obj = {};
    if ($x) {
      obj.x = $x;
    }
    if ($y) {
      obj.y = $y;
    }
    if ($z) {
      obj.z = $z;
    }
    if ($r) {
      obj.r = $r;
    }
    return obj;
  });
  const padding_d = derived([_padding, _containerWidth, _containerHeight], ([$padding]) => {
    const defaultPadding = { top: 0, right: 0, bottom: 0, left: 0 };
    return Object.assign(defaultPadding, $padding);
  });
  const box_d = derived([_containerWidth, _containerHeight, padding_d], ([$containerWidth, $containerHeight, $padding]) => {
    const b = {};
    b.top = $padding.top;
    b.right = $containerWidth - $padding.right;
    b.bottom = $containerHeight - $padding.bottom;
    b.left = $padding.left;
    b.width = b.right - b.left;
    b.height = b.bottom - b.top;
    if (strict_equals(verbose(), true)) {
      if (b.width <= 0 && strict_equals(isMounted, true)) {
        console.warn(...log_if_contains_state("warn", "[LayerCake] Target div has zero or negative width. Did you forget to set an explicit width in CSS on the container?"));
      }
      if (b.height <= 0 && strict_equals(isMounted, true)) {
        console.warn(...log_if_contains_state("warn", "[LayerCake] Target div has zero or negative height. Did you forget to set an explicit height in CSS on the container?"));
      }
    }
    return b;
  });
  const width_d = derived([box_d], ([$box]) => {
    return $box.width;
  });
  const height_d = derived([box_d], ([$box]) => {
    return $box.height;
  });
  const extents_d = derived(
    [
      _flatData,
      activeGetters_d,
      _extents,
      _xScale,
      _yScale,
      _rScale,
      _zScale,
      _xDomainSort,
      _yDomainSort,
      _zDomainSort,
      _rDomainSort
    ],
    ([
      $flatData,
      $activeGetters,
      $extents,
      $_xScale2,
      $_yScale2,
      $_rScale2,
      $_zScale2,
      $_xDomainSort2,
      $_yDomainSort2,
      $_zDomainSort2,
      $_rDomainSort2
    ]) => {
      const scaleLookup = {
        x: { scale: $_xScale2, sort: $_xDomainSort2 },
        y: { scale: $_yScale2, sort: $_yDomainSort2 },
        r: { scale: $_rScale2, sort: $_rDomainSort2 },
        z: { scale: $_zScale2, sort: $_zDomainSort2 }
      };
      const getters = filterObject($activeGetters, $extents);
      const activeScales = Object.fromEntries(Object.keys(getters).map((k) => [k, scaleLookup[k]]));
      if (Object.keys(getters).length > 0) {
        const calculatedExtents = calcScaleExtents($flatData, getters, activeScales);
        return { ...calculatedExtents, ...$extents };
      } else {
        return {};
      }
    }
  );
  const xDomain_d = derived([extents_d, _xDomain], calcDomain("x"));
  const yDomain_d = derived([extents_d, _yDomain], calcDomain("y"));
  const zDomain_d = derived([extents_d, _zDomain], calcDomain("z"));
  const rDomain_d = derived([extents_d, _rDomain], calcDomain("r"));
  const xScale_d = derived(
    [
      _xScale,
      extents_d,
      xDomain_d,
      _xPadding,
      _xNice,
      _xReverse,
      width_d,
      height_d,
      _xRange,
      _percentRange
    ],
    createScale("x")
  );
  const xGet_d = derived([_x, xScale_d], createGetter);
  const yScale_d = derived(
    [
      _yScale,
      extents_d,
      yDomain_d,
      _yPadding,
      _yNice,
      _yReverse,
      width_d,
      height_d,
      _yRange,
      _percentRange
    ],
    createScale("y")
  );
  const yGet_d = derived([_y, yScale_d], createGetter);
  const zScale_d = derived(
    [
      _zScale,
      extents_d,
      zDomain_d,
      _zPadding,
      _zNice,
      _zReverse,
      width_d,
      height_d,
      _zRange,
      _percentRange
    ],
    createScale("z")
  );
  const zGet_d = derived([_z, zScale_d], createGetter);
  const rScale_d = derived(
    [
      _rScale,
      extents_d,
      rDomain_d,
      _rPadding,
      _rNice,
      _rReverse,
      width_d,
      height_d,
      _rRange,
      _percentRange
    ],
    createScale("r")
  );
  const rGet_d = derived([_r, rScale_d], createGetter);
  const xDomain_d_possibly_nice = derived(xScale_d, ($xScale_d2) => $xScale_d2.domain());
  const yDomain_d_possibly_nice = derived(yScale_d, ($yScale_d2) => $yScale_d2.domain());
  const zDomain_d_possibly_nice = derived(zScale_d, ($zScale_d2) => $zScale_d2.domain());
  const rDomain_d_possibly_nice = derived(rScale_d, ($rScale_d2) => $rScale_d2.domain());
  const xRange_d = derived([xScale_d], getRange);
  const yRange_d = derived([yScale_d], getRange);
  const zRange_d = derived([zScale_d], getRange);
  const rRange_d = derived([rScale_d], getRange);
  const aspectRatio_d = derived([width_d, height_d], ([$width, $height]) => {
    return $width / $height;
  });
  legacy_pre_effect(
    () => (deep_read_state(yReverse()), deep_read_state(yScale())),
    () => {
      set(yReverseValue, strict_equals(typeof yReverse(), "undefined") ? strict_equals(typeof yScale().bandwidth, "function") ? false : true : yReverse());
    }
  );
  legacy_pre_effect(() => deep_read_state(x()), () => {
    if (x()) mutate(config, get(config).x = x());
  });
  legacy_pre_effect(() => deep_read_state(y()), () => {
    if (y()) mutate(config, get(config).y = y());
  });
  legacy_pre_effect(() => deep_read_state(z()), () => {
    if (z()) mutate(config, get(config).z = z());
  });
  legacy_pre_effect(() => deep_read_state(r()), () => {
    if (r()) mutate(config, get(config).r = r());
  });
  legacy_pre_effect(() => deep_read_state(xDomain()), () => {
    if (xDomain()) mutate(config, get(config).xDomain = xDomain());
  });
  legacy_pre_effect(() => deep_read_state(yDomain()), () => {
    if (yDomain()) mutate(config, get(config).yDomain = yDomain());
  });
  legacy_pre_effect(() => deep_read_state(zDomain()), () => {
    if (zDomain()) mutate(config, get(config).zDomain = zDomain());
  });
  legacy_pre_effect(() => deep_read_state(rDomain()), () => {
    if (rDomain()) mutate(config, get(config).rDomain = rDomain());
  });
  legacy_pre_effect(() => deep_read_state(xRange()), () => {
    if (xRange()) mutate(config, get(config).xRange = xRange());
  });
  legacy_pre_effect(() => deep_read_state(yRange()), () => {
    if (yRange()) mutate(config, get(config).yRange = yRange());
  });
  legacy_pre_effect(() => deep_read_state(zRange()), () => {
    if (zRange()) mutate(config, get(config).zRange = zRange());
  });
  legacy_pre_effect(() => deep_read_state(rRange()), () => {
    if (rRange()) mutate(config, get(config).rRange = rRange());
  });
  legacy_pre_effect(() => deep_read_state(percentRange()), () => {
    store_set(_percentRange, percentRange());
  });
  legacy_pre_effect(() => deep_read_state(containerWidth()), () => {
    store_set(_containerWidth, containerWidth());
  });
  legacy_pre_effect(() => deep_read_state(containerHeight()), () => {
    store_set(_containerHeight, containerHeight());
  });
  legacy_pre_effect(
    () => (filterObject, deep_read_state(extents())),
    () => {
      store_set(_extents, filterObject(extents()));
    }
  );
  legacy_pre_effect(() => deep_read_state(data()), () => {
    store_set(_data, data());
  });
  legacy_pre_effect(
    () => (deep_read_state(flatData()), deep_read_state(data())),
    () => {
      store_set(_flatData, flatData() || data());
    }
  );
  legacy_pre_effect(() => deep_read_state(padding()), () => {
    store_set(_padding, padding());
  });
  legacy_pre_effect(() => (makeAccessor, deep_read_state(x())), () => {
    store_set(_x, makeAccessor(x()));
  });
  legacy_pre_effect(() => (makeAccessor, deep_read_state(y())), () => {
    store_set(_y, makeAccessor(y()));
  });
  legacy_pre_effect(() => (makeAccessor, deep_read_state(z())), () => {
    store_set(_z, makeAccessor(z()));
  });
  legacy_pre_effect(() => (makeAccessor, deep_read_state(r())), () => {
    store_set(_r, makeAccessor(r()));
  });
  legacy_pre_effect(() => deep_read_state(xDomain()), () => {
    store_set(_xDomain, xDomain());
  });
  legacy_pre_effect(() => deep_read_state(yDomain()), () => {
    store_set(_yDomain, yDomain());
  });
  legacy_pre_effect(() => deep_read_state(zDomain()), () => {
    store_set(_zDomain, zDomain());
  });
  legacy_pre_effect(() => deep_read_state(rDomain()), () => {
    store_set(_rDomain, rDomain());
  });
  legacy_pre_effect(() => deep_read_state(xNice()), () => {
    store_set(_xNice, xNice());
  });
  legacy_pre_effect(() => deep_read_state(yNice()), () => {
    store_set(_yNice, yNice());
  });
  legacy_pre_effect(() => deep_read_state(zNice()), () => {
    store_set(_zNice, zNice());
  });
  legacy_pre_effect(() => deep_read_state(rNice()), () => {
    store_set(_rNice, rNice());
  });
  legacy_pre_effect(() => deep_read_state(xReverse()), () => {
    store_set(_xReverse, xReverse());
  });
  legacy_pre_effect(() => get(yReverseValue), () => {
    store_set(_yReverse, get(yReverseValue));
  });
  legacy_pre_effect(() => deep_read_state(zReverse()), () => {
    store_set(_zReverse, zReverse());
  });
  legacy_pre_effect(() => deep_read_state(rReverse()), () => {
    store_set(_rReverse, rReverse());
  });
  legacy_pre_effect(() => deep_read_state(xPadding()), () => {
    store_set(_xPadding, xPadding());
  });
  legacy_pre_effect(() => deep_read_state(yPadding()), () => {
    store_set(_yPadding, yPadding());
  });
  legacy_pre_effect(() => deep_read_state(zPadding()), () => {
    store_set(_zPadding, zPadding());
  });
  legacy_pre_effect(() => deep_read_state(rPadding()), () => {
    store_set(_rPadding, rPadding());
  });
  legacy_pre_effect(() => deep_read_state(xRange()), () => {
    store_set(_xRange, xRange());
  });
  legacy_pre_effect(() => deep_read_state(yRange()), () => {
    store_set(_yRange, yRange());
  });
  legacy_pre_effect(() => deep_read_state(zRange()), () => {
    store_set(_zRange, zRange());
  });
  legacy_pre_effect(() => deep_read_state(rRange()), () => {
    store_set(_rRange, rRange());
  });
  legacy_pre_effect(() => deep_read_state(xScale()), () => {
    store_set(_xScale, xScale());
  });
  legacy_pre_effect(() => deep_read_state(yScale()), () => {
    store_set(_yScale, yScale());
  });
  legacy_pre_effect(() => deep_read_state(zScale()), () => {
    store_set(_zScale, zScale());
  });
  legacy_pre_effect(() => deep_read_state(rScale()), () => {
    store_set(_rScale, rScale());
  });
  legacy_pre_effect(() => deep_read_state(custom()), () => {
    store_set(_custom, custom());
  });
  legacy_pre_effect(() => get(config), () => {
    store_set(_config, get(config));
  });
  legacy_pre_effect(() => {
  }, () => {
    set(context, {
      activeGetters: activeGetters_d,
      width: width_d,
      height: height_d,
      percentRange: _percentRange,
      aspectRatio: aspectRatio_d,
      containerWidth: _containerWidth,
      containerHeight: _containerHeight,
      x: _x,
      y: _y,
      z: _z,
      r: _r,
      custom: _custom,
      data: _data,
      xNice: _xNice,
      yNice: _yNice,
      zNice: _zNice,
      rNice: _rNice,
      xDomainSort: _xDomainSort,
      yDomainSort: _yDomainSort,
      zDomainSort: _zDomainSort,
      rDomainSort: _rDomainSort,
      xReverse: _xReverse,
      yReverse: _yReverse,
      zReverse: _zReverse,
      rReverse: _rReverse,
      xPadding: _xPadding,
      yPadding: _yPadding,
      zPadding: _zPadding,
      rPadding: _rPadding,
      padding: padding_d,
      flatData: _flatData,
      extents: extents_d,
      xDomain: xDomain_d_possibly_nice,
      yDomain: yDomain_d_possibly_nice,
      zDomain: zDomain_d_possibly_nice,
      rDomain: rDomain_d_possibly_nice,
      xRange: xRange_d,
      yRange: yRange_d,
      zRange: zRange_d,
      rRange: rRange_d,
      config: _config,
      xScale: xScale_d,
      xGet: xGet_d,
      yScale: yScale_d,
      yGet: yGet_d,
      zScale: zScale_d,
      zGet: zGet_d,
      rScale: rScale_d,
      rGet: rGet_d
    });
  });
  legacy_pre_effect(() => (setContext, get(context)), () => {
    setContext("LayerCake", get(context));
  });
  legacy_pre_effect(
    () => ($box_d(), deep_read_state(debug()), deep_read_state(ssr()), $_data(), deep_read_state(flatData()), $_flatData(), $activeGetters_d(), get(config), $xScale_d(), $yScale_d(), $zScale_d(), $rScale_d()),
    () => {
      if ($box_d() && strict_equals(debug(), true) && (strict_equals(ssr(), true) || strict_equals(typeof window, "undefined", false))) {
        printDebug_debounced({
          data: $_data(),
          flatData: strict_equals(typeof flatData(), "undefined", false) ? $_flatData() : null,
          boundingBox: $box_d(),
          activeGetters: $activeGetters_d(),
          x: get(config).x,
          y: get(config).y,
          z: get(config).z,
          r: get(config).r,
          xScale: $xScale_d(),
          yScale: $yScale_d(),
          zScale: $zScale_d(),
          rScale: $rScale_d()
        });
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => strict_equals(ssr(), true) || strict_equals(typeof window, "undefined", false), ($$anchor2) => {
    var div = root_1();
    bind_this(div, ($$value) => element($$value), () => element());
    var node_1 = child(div);
    slot(
      node_1,
      $$props,
      "default",
      {
        get element() {
          return element();
        },
        get width() {
          return $width_d();
        },
        get height() {
          return $height_d();
        },
        get aspectRatio() {
          return $aspectRatio_d();
        },
        get containerWidth() {
          return $_containerWidth();
        },
        get containerHeight() {
          return $_containerHeight();
        },
        get activeGetters() {
          return $activeGetters_d();
        },
        get percentRange() {
          return $_percentRange();
        },
        get x() {
          return $_x();
        },
        get y() {
          return $_y();
        },
        get z() {
          return $_z();
        },
        get r() {
          return $_r();
        },
        get custom() {
          return $_custom();
        },
        get data() {
          return $_data();
        },
        get xNice() {
          return $_xNice();
        },
        get yNice() {
          return $_yNice();
        },
        get zNice() {
          return $_zNice();
        },
        get rNice() {
          return $_rNice();
        },
        get xDomainSort() {
          return $_xDomainSort();
        },
        get yDomainSort() {
          return $_yDomainSort();
        },
        get zDomainSort() {
          return $_zDomainSort();
        },
        get rDomainSort() {
          return $_rDomainSort();
        },
        get xReverse() {
          return $_xReverse();
        },
        get yReverse() {
          return $_yReverse();
        },
        get zReverse() {
          return $_zReverse();
        },
        get rReverse() {
          return $_rReverse();
        },
        get xPadding() {
          return $_xPadding();
        },
        get yPadding() {
          return $_yPadding();
        },
        get zPadding() {
          return $_zPadding();
        },
        get rPadding() {
          return $_rPadding();
        },
        get padding() {
          return $padding_d();
        },
        get flatData() {
          return $_flatData();
        },
        get extents() {
          return $extents_d();
        },
        get xDomain() {
          return $xDomain_d();
        },
        get yDomain() {
          return $yDomain_d();
        },
        get zDomain() {
          return $zDomain_d();
        },
        get rDomain() {
          return $rDomain_d();
        },
        get xRange() {
          return $xRange_d();
        },
        get yRange() {
          return $yRange_d();
        },
        get zRange() {
          return $zRange_d();
        },
        get rRange() {
          return $rRange_d();
        },
        get config() {
          return $_config();
        },
        get xScale() {
          return $xScale_d();
        },
        get xGet() {
          return $xGet_d();
        },
        get yScale() {
          return $yScale_d();
        },
        get yGet() {
          return $yGet_d();
        },
        get zScale() {
          return $zScale_d();
        },
        get zGet() {
          return $zGet_d();
        },
        get rScale() {
          return $rScale_d();
        },
        get rGet() {
          return $rGet_d();
        }
      },
      null
    );
    reset(div);
    template_effect(() => {
      set_style(div, "position", position());
      set_style(div, "top", strict_equals(position(), "absolute") ? "0" : null);
      set_style(div, "right", strict_equals(position(), "absolute") ? "0" : null);
      set_style(div, "bottom", strict_equals(position(), "absolute") ? "0" : null);
      set_style(div, "left", strict_equals(position(), "absolute") ? "0" : null);
      set_style(div, "pointer-events", strict_equals(pointerEvents(), false) ? "none" : null);
    });
    bind_element_size(div, "clientWidth", containerWidth);
    bind_element_size(div, "clientHeight", containerHeight);
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LayerCake = hmr(LayerCake, () => LayerCake[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-iXYfEl0mczxA");
    module.default[HMR].source = LayerCake[HMR].source;
    set(LayerCake[HMR].source, module.default[HMR].original);
  });
}
var LayerCake_default = LayerCake;
mark_module_end(LayerCake);

// node_modules/layercake/dist/layouts/Html.svelte
mark_module_start();
Html[FILENAME] = "node_modules/layercake/dist/layouts/Html.svelte";
var root = add_locations(template(`<div class="layercake-layout-html s-mew6NoKkJi2X"><!></div>`), Html[FILENAME], [[34, 0]]);
var $$css2 = {
  hash: "s-mew6NoKkJi2X",
  code: "\n	div.s-mew6NoKkJi2X {\n		position: absolute;\n		top: 0;\n		left: 0;\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSHRtbC5zdmVsdGUiLCJtYXBwaW5ncyI6IjtBQW1EQSxDQUFDLGtCQUFHLENBQUM7QUFDTCxFQUFFLGtCQUFrQjtBQUNwQixFQUFFLE1BQU07QUFDUixFQUFFLE9BQU87QUFDVCIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiSHRtbC5zdmVsdGUiXX0= */"
};
function Html($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Html);
  append_styles($$anchor, $$css2);
  const $$stores = setup_stores();
  const $padding = () => (validate_store(padding, "padding"), store_get(padding, "$padding", $$stores));
  const roleVal = mutable_state();
  const { padding } = getContext("LayerCake");
  let element = prop($$props, "element", 12, void 0);
  let zIndex = prop($$props, "zIndex", 8, void 0);
  let pointerEvents = prop($$props, "pointerEvents", 8, void 0);
  let role = prop($$props, "role", 8, void 0);
  let label = prop($$props, "label", 8, void 0);
  let labelledBy = prop($$props, "labelledBy", 8, void 0);
  let describedBy = prop($$props, "describedBy", 8, void 0);
  legacy_pre_effect(
    () => (deep_read_state(role()), deep_read_state(label()), deep_read_state(labelledBy()), deep_read_state(describedBy())),
    () => {
      set(roleVal, role() || (label() || labelledBy() || describedBy() ? "figure" : void 0));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root();
  bind_this(div, ($$value) => element($$value), () => element());
  var node = child(div);
  slot(
    node,
    $$props,
    "default",
    {
      get element() {
        return element();
      }
    },
    null
  );
  reset(div);
  template_effect(() => {
    set_attribute(div, "role", get(roleVal));
    set_attribute(div, "aria-label", label());
    set_attribute(div, "aria-labelledby", labelledBy());
    set_attribute(div, "aria-describedby", describedBy());
    set_style(div, "z-index", zIndex());
    set_style(div, "pointer-events", strict_equals(pointerEvents(), false) ? "none" : null);
    set_style(div, "top", $padding().top + "px");
    set_style(div, "right", $padding().right + "px");
    set_style(div, "bottom", $padding().bottom + "px");
    set_style(div, "left", $padding().left + "px");
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Html = hmr(Html, () => Html[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-mew6NoKkJi2X");
    module.default[HMR].source = Html[HMR].source;
    set(Html[HMR].source, module.default[HMR].original);
  });
}
var Html_default = Html;
mark_module_end(Html);

// node_modules/layercake/dist/layouts/Svg.svelte
mark_module_start();
Svg[FILENAME] = "node_modules/layercake/dist/layouts/Svg.svelte";
var root_2 = add_locations(template(`<title> </title>`), Svg[FILENAME], [[51, 14]]);
var root2 = add_locations(ns_template(`<svg class="layercake-layout-svg s-mNMq-OFA8Ag4"><!><defs><!></defs><g class="layercake-layout-svg_g"><!></g></svg>`), Svg[FILENAME], [
  [38, 0, [[54, 1], [57, 1]]]
]);
var $$css3 = {
  hash: "s-mNMq-OFA8Ag4",
  code: "\n	svg.s-mNMq-OFA8Ag4 {\n		position: absolute;\n		top: 0;\n		left: 0;\n		overflow: visible;\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZnLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiO0FBa0VBLENBQUMsa0JBQUcsQ0FBQztBQUNMLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsTUFBTTtBQUNSLEVBQUUsT0FBTztBQUNULEVBQUUsaUJBQWlCO0FBQ25CIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJTdmcuc3ZlbHRlIl19 */"
};
function Svg($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Svg);
  append_styles($$anchor, $$css3);
  const $$stores = setup_stores();
  const $containerWidth = () => (validate_store(containerWidth, "containerWidth"), store_get(containerWidth, "$containerWidth", $$stores));
  const $containerHeight = () => (validate_store(containerHeight, "containerHeight"), store_get(containerHeight, "$containerHeight", $$stores));
  const $padding = () => (validate_store(padding, "padding"), store_get(padding, "$padding", $$stores));
  let element = prop($$props, "element", 12, void 0);
  let innerElement = prop($$props, "innerElement", 12, void 0);
  let zIndex = prop($$props, "zIndex", 8, void 0);
  let pointerEvents = prop($$props, "pointerEvents", 8, void 0);
  let viewBox = prop($$props, "viewBox", 8, void 0);
  let label = prop($$props, "label", 8, void 0);
  let labelledBy = prop($$props, "labelledBy", 8, void 0);
  let describedBy = prop($$props, "describedBy", 8, void 0);
  let title = prop($$props, "title", 8, void 0);
  const { containerWidth, containerHeight, padding } = getContext("LayerCake");
  init();
  var svg = root2();
  bind_this(svg, ($$value) => element($$value), () => element());
  var node = child(svg);
  slot(node, $$props, "title", {}, ($$anchor2) => {
    var fragment = comment();
    var node_1 = first_child(fragment);
    if_block(node_1, title, ($$anchor3) => {
      var title_1 = root_2();
      var text2 = child(title_1);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor3, title_1);
    });
    append($$anchor2, fragment);
  });
  var defs = sibling(node);
  var node_2 = child(defs);
  slot(node_2, $$props, "defs", {}, null);
  reset(defs);
  var g = sibling(defs);
  bind_this(g, ($$value) => innerElement($$value), () => innerElement());
  var node_3 = child(g);
  slot(
    node_3,
    $$props,
    "default",
    {
      get element() {
        return element();
      }
    },
    null
  );
  reset(g);
  reset(svg);
  template_effect(() => {
    set_attribute(svg, "viewBox", viewBox());
    set_attribute(svg, "width", $containerWidth());
    set_attribute(svg, "height", $containerHeight());
    set_attribute(svg, "aria-label", label());
    set_attribute(svg, "aria-labelledby", labelledBy());
    set_attribute(svg, "aria-describedby", describedBy());
    set_style(svg, "z-index", zIndex());
    set_style(svg, "pointer-events", strict_equals(pointerEvents(), false) ? "none" : null);
    set_attribute(g, "transform", `translate(${$padding().left ?? ""}, ${$padding().top ?? ""})`);
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Svg = hmr(Svg, () => Svg[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-mNMq-OFA8Ag4");
    module.default[HMR].source = Svg[HMR].source;
    set(Svg[HMR].source, module.default[HMR].original);
  });
}
var Svg_default = Svg;
mark_module_end(Svg);

// node_modules/layercake/dist/layouts/ScaledSvg.svelte
mark_module_start();
ScaledSvg[FILENAME] = "node_modules/layercake/dist/layouts/ScaledSvg.svelte";
var root_22 = add_locations(template(`<title> </title>`), ScaledSvg[FILENAME], [[55, 14]]);
var root3 = add_locations(ns_template(`<svg preserveAspectRatio="none" style="right:0px; bottom:0px;" class="s-R1NF3Zisjvzo"><!><defs><!></defs><!></svg>`), ScaledSvg[FILENAME], [[39, 0, [[58, 1]]]]);
var $$css4 = {
  hash: "s-R1NF3Zisjvzo",
  code: "\n	svg.s-R1NF3Zisjvzo {\n		position: absolute;\n		width: 100%;\n		height: 100%;\n		overflow: visible;\n	}\n	svg.s-R1NF3Zisjvzo * {\n		vector-effect: non-scaling-stroke;\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NhbGVkU3ZnLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiO0FBaUVBLENBQUMsa0JBQUcsQ0FBQztBQUNMLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsV0FBVztBQUNiLEVBQUUsWUFBWTtBQUNkLEVBQUUsaUJBQWlCO0FBQ25CO0FBQ0EsQ0FBQyxrQkFBRyxDQUFTLENBQUUsQ0FBQztBQUNoQixFQUFFLGlDQUFpQztBQUNuQyIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiU2NhbGVkU3ZnLnN2ZWx0ZSJdfQ== */"
};
function ScaledSvg($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ScaledSvg);
  append_styles($$anchor, $$css4);
  const $$stores = setup_stores();
  const $padding = () => (validate_store(padding, "padding"), store_get(padding, "$padding", $$stores));
  const { padding } = getContext("LayerCake");
  let element = prop($$props, "element", 12, void 0);
  let zIndex = prop($$props, "zIndex", 8, void 0);
  let pointerEvents = prop($$props, "pointerEvents", 8, void 0);
  let fixedAspectRatio = prop($$props, "fixedAspectRatio", 8, 1);
  let viewBox = prop($$props, "viewBox", 28, () => `0 0 100 ${100 / fixedAspectRatio()}`);
  let label = prop($$props, "label", 8, void 0);
  let labelledBy = prop($$props, "labelledBy", 8, void 0);
  let describedBy = prop($$props, "describedBy", 8, void 0);
  let title = prop($$props, "title", 8, void 0);
  legacy_pre_effect(() => deep_read_state(fixedAspectRatio()), () => {
    viewBox(`0 0 100 ${100 / fixedAspectRatio()}`);
  });
  legacy_pre_effect_reset();
  init();
  var svg = root3();
  bind_this(svg, ($$value) => element($$value), () => element());
  var node = child(svg);
  slot(node, $$props, "title", {}, ($$anchor2) => {
    var fragment = comment();
    var node_1 = first_child(fragment);
    if_block(node_1, title, ($$anchor3) => {
      var title_1 = root_22();
      var text2 = child(title_1);
      reset(title_1);
      template_effect(() => set_text(text2, title()));
      append($$anchor3, title_1);
    });
    append($$anchor2, fragment);
  });
  var defs = sibling(node);
  var node_2 = child(defs);
  slot(node_2, $$props, "defs", {}, null);
  reset(defs);
  var node_3 = sibling(defs);
  slot(
    node_3,
    $$props,
    "default",
    {
      get element() {
        return element();
      }
    },
    null
  );
  reset(svg);
  template_effect(() => {
    set_attribute(svg, "viewBox", viewBox());
    set_attribute(svg, "aria-label", label());
    set_attribute(svg, "aria-labelledby", labelledBy());
    set_attribute(svg, "aria-describedby", describedBy());
    set_style(svg, "z-index", zIndex(), void 0, true);
    set_style(svg, "pointer-events", strict_equals(pointerEvents(), false) ? "none" : null, void 0, true);
    set_style(svg, "top", $padding().top + "px", void 0, true);
    set_style(svg, "left", $padding().left + "px", void 0, true);
    set_style(svg, "width", `calc(100% - ${$padding().left + $padding().right}px)`, void 0, true);
    set_style(svg, "height", `calc(100% - ${$padding().top + $padding().bottom}px)`, void 0, true);
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ScaledSvg = hmr(ScaledSvg, () => ScaledSvg[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-R1NF3Zisjvzo");
    module.default[HMR].source = ScaledSvg[HMR].source;
    set(ScaledSvg[HMR].source, module.default[HMR].original);
  });
}
var ScaledSvg_default = ScaledSvg;
mark_module_end(ScaledSvg);

// node_modules/layercake/dist/lib/scaleCanvas.js
function scaleCanvas_default(ctx, width, height) {
  const dpr = window.devicePixelRatio || 1;
  ctx.canvas.width = width * dpr;
  ctx.canvas.height = height * dpr;
  ctx.canvas.style.width = `${width}px`;
  ctx.canvas.style.height = `${height}px`;
  ctx.scale(dpr, dpr);
  return { width: ctx.canvas.width, height: ctx.canvas.height };
}

// node_modules/layercake/dist/layouts/Canvas.svelte
mark_module_start();
Canvas[FILENAME] = "node_modules/layercake/dist/layouts/Canvas.svelte";
var root4 = add_locations(template(`<canvas class="layercake-layout-canvas" style="width:100%;height:100%;position:absolute;"><!></canvas> <!>`, 1), Canvas[FILENAME], [[49, 0]]);
function Canvas($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Canvas);
  const $$stores = setup_stores();
  const $width = () => (validate_store(width, "width"), store_get(width, "$width", $$stores));
  const $height = () => (validate_store(height, "height"), store_get(height, "$height", $$stores));
  const $padding = () => (validate_store(padding, "padding"), store_get(padding, "$padding", $$stores));
  const { width, height, padding } = getContext("LayerCake");
  let element = prop($$props, "element", 12, void 0);
  let context = prop($$props, "context", 12, void 0);
  let zIndex = prop($$props, "zIndex", 8, void 0);
  let pointerEvents = prop($$props, "pointerEvents", 8, void 0);
  let fallback = prop($$props, "fallback", 8, "");
  let label = prop($$props, "label", 8, void 0);
  let labelledBy = prop($$props, "labelledBy", 8, void 0);
  let describedBy = prop($$props, "describedBy", 8, void 0);
  const cntxt = { ctx: writable({}) };
  onMount(() => {
    context(element().getContext("2d"));
    scaleCanvas_default(context(), $width(), $height());
  });
  setContext("canvas", cntxt);
  legacy_pre_effect(() => deep_read_state(context()), () => {
    cntxt.ctx.set(context());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = root4();
  var canvas = first_child(fragment);
  bind_this(canvas, ($$value) => element($$value), () => element());
  var node = child(canvas);
  slot(node, $$props, "fallback", {}, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    if_block(node_1, fallback, ($$anchor3) => {
      var text2 = text();
      template_effect(() => set_text(text2, fallback()));
      append($$anchor3, text2);
    });
    append($$anchor2, fragment_1);
  });
  reset(canvas);
  var node_2 = sibling(canvas, 2);
  slot(
    node_2,
    $$props,
    "default",
    {
      get element() {
        return element();
      },
      get context() {
        return context();
      }
    },
    null
  );
  template_effect(() => {
    set_attribute(canvas, "aria-label", label());
    set_attribute(canvas, "aria-labelledby", labelledBy());
    set_attribute(canvas, "aria-describedby", describedBy());
    set_style(canvas, "z-index", zIndex(), void 0, true);
    set_style(canvas, "pointer-events", strict_equals(pointerEvents(), false) ? "none" : null, void 0, true);
    set_style(canvas, "top", $padding().top + "px", void 0, true);
    set_style(canvas, "right", $padding().right + "px", void 0, true);
    set_style(canvas, "bottom", $padding().bottom + "px", void 0, true);
    set_style(canvas, "left", $padding().left + "px", void 0, true);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Canvas = hmr(Canvas, () => Canvas[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Canvas[HMR].source;
    set(Canvas[HMR].source, module.default[HMR].original);
  });
}
var Canvas_default = Canvas;
mark_module_end(Canvas);

// node_modules/layercake/dist/layouts/Webgl.svelte
mark_module_start();
Webgl[FILENAME] = "node_modules/layercake/dist/layouts/Webgl.svelte";
var root5 = add_locations(template(`<canvas class="layercake-layout-webgl" style="width:100%;height:100%;position:absolute;"><!></canvas> <!>`, 1), Webgl[FILENAME], [[63, 0]]);
function Webgl($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Webgl);
  const $$stores = setup_stores();
  const $padding = () => (validate_store(padding, "padding"), store_get(padding, "$padding", $$stores));
  let element = prop($$props, "element", 12, void 0);
  let zIndex = prop($$props, "zIndex", 8, void 0);
  let pointerEvents = prop($$props, "pointerEvents", 8, void 0);
  let contextAttributes = prop($$props, "contextAttributes", 8, void 0);
  let context = prop($$props, "context", 12, void 0);
  let fallback = prop($$props, "fallback", 8, "");
  let label = prop($$props, "label", 8, void 0);
  let labelledBy = prop($$props, "labelledBy", 8, void 0);
  let describedBy = prop($$props, "describedBy", 8, void 0);
  let testGl;
  const { padding } = getContext("LayerCake");
  const cntxt = { gl: writable({}) };
  onMount(() => {
    const contexts = [
      "webgl",
      "experimental-webgl",
      "moz-webgl",
      "webkit-3d"
    ];
    for (let j = 0; j < contexts.length; (j += 1) - 1) {
      testGl = element().getContext(contexts[j], contextAttributes());
      if (testGl) {
        context(testGl);
        break;
      }
    }
  });
  setContext("gl", cntxt);
  legacy_pre_effect(() => deep_read_state(context()), () => {
    cntxt.gl.set(context());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = root5();
  var canvas = first_child(fragment);
  bind_this(canvas, ($$value) => element($$value), () => element());
  var node = child(canvas);
  slot(node, $$props, "fallback", {}, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    if_block(node_1, fallback, ($$anchor3) => {
      var text2 = text();
      template_effect(() => set_text(text2, fallback()));
      append($$anchor3, text2);
    });
    append($$anchor2, fragment_1);
  });
  reset(canvas);
  var node_2 = sibling(canvas, 2);
  slot(
    node_2,
    $$props,
    "default",
    {
      get element() {
        return element();
      },
      get context() {
        return context();
      }
    },
    null
  );
  template_effect(() => {
    set_attribute(canvas, "aria-label", label());
    set_attribute(canvas, "aria-labelledby", labelledBy());
    set_attribute(canvas, "aria-describedby", describedBy());
    set_style(canvas, "z-index", zIndex(), void 0, true);
    set_style(canvas, "pointer-events", strict_equals(pointerEvents(), false) ? "none" : null, void 0, true);
    set_style(canvas, "top", $padding().top + "px", void 0, true);
    set_style(canvas, "right", $padding().right + "px", void 0, true);
    set_style(canvas, "bottom", $padding().bottom + "px", void 0, true);
    set_style(canvas, "left", $padding().left + "px", void 0, true);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Webgl = hmr(Webgl, () => Webgl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Webgl[HMR].source;
    set(Webgl[HMR].source, module.default[HMR].original);
  });
}
var Webgl_default = Webgl;
mark_module_end(Webgl);

// node_modules/layercake/dist/lib/flatten.js
function flatten(list, accessor = (d) => d) {
  const acc = typeof accessor === "string" ? (d) => d[accessor] : accessor;
  if (Array.isArray(list) && Array.isArray(acc(list[0]))) {
    let flat = [];
    const l = list.length;
    for (let i = 0; i < l; i += 1) {
      flat = flat.concat(acc(list[i]));
    }
    return flat;
  }
  return list;
}

// node_modules/layercake/dist/lib/uniques.js
function uniques(list, accessor, transform = true) {
  if (!Array.isArray(list)) {
    console.error("LayerCake error: Input value to `uniques` must be a list.");
    return null;
  }
  const ll = list.length;
  const iterater = typeof accessor === "function";
  const key = typeof accessor !== "undefined";
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  for (let i = 0; i < ll; i += 1) {
    const d = list[i];
    const computed = iterater ? accessor(d) : key === true ? d[accessor] : d;
    if (!seen.has(computed)) {
      seen.add(computed);
      result.push(transform ? computed : d);
    }
  }
  return result;
}

// node_modules/layercake/dist/lib/raise.js
function raise(el) {
  if (el.nextSibling) el.parentNode.appendChild(el);
}

// node_modules/layercake/dist/lib/takeEvery.js
function takeEvery(list, n) {
  if (list.length <= n) return list;
  const e = Math.round(list.length / n);
  return list.filter((d, i) => {
    return i % e === 0;
  });
}

// node_modules/layercake/dist/lib/bin.js
function bin2(data, value, { domain, thresholds } = {}) {
  if (typeof data !== "object") {
    throw new TypeError("The first argument of bin() must be an array or data object");
  }
  let hist = bin();
  if (value) {
    const acc = typeof value === "function" ? value : (d) => d[value];
    hist = hist.value(acc);
  }
  if (domain) {
    hist = hist.domain(domain);
  }
  if (thresholds) {
    hist = hist.thresholds(thresholds);
  }
  return hist(data);
}

// node_modules/layercake/dist/lib/stack.js
function stack(data, keys, { value, order, offset } = {}) {
  if (typeof data !== "object") {
    throw new TypeError("The first argument of stack() must be an array or data object");
  }
  if (!Array.isArray(keys)) {
    throw new TypeError("The second argument of stack() must be an array of key names");
  }
  let stacker = stack_default().keys(keys);
  if (value) {
    stacker = stacker.value(value);
  }
  if (order) {
    stacker = stacker.order(order);
  }
  if (offset) {
    stacker = stacker.offset(offset);
  }
  return stacker(data);
}

// node_modules/layercake/dist/lib/groupLonger.js
function groupLonger(data, keys, { groupTo = "group", valueTo = "value", keepKeys = void 0 } = {}) {
  if (!Array.isArray(data)) {
    throw new TypeError("The first argument of groupLonger() must be an array of data");
  }
  if (!Array.isArray(keys)) {
    throw new TypeError("The second argument of groupLonger() must be an array of key names");
  }
  const keysSet = new Set(keys);
  const keep = keepKeys || Object.keys(data[0]).filter((d) => !keysSet.has(d));
  return keys.map((key) => {
    return {
      [groupTo]: key,
      values: data.map((d) => {
        return {
          ...Object.fromEntries(keep.map((k) => [k, d[k]])),
          [valueTo]: d[key],
          [groupTo]: key
        };
      })
    };
  });
}
export {
  Canvas_default as Canvas,
  Html_default as Html,
  LayerCake_default as LayerCake,
  ScaledSvg_default as ScaledSvg,
  Svg_default as Svg,
  Webgl_default as WebGL,
  bin2 as bin,
  calcExtents,
  flatten,
  groupLonger,
  raise,
  scaleCanvas_default as scaleCanvas,
  stack,
  takeEvery,
  uniques
};
//# sourceMappingURL=layercake.js.map
